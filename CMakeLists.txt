cmake_minimum_required(VERSION 3.0)

# project info
project(arbor)
enable_language(CXX)

# Hide warnings about mixing old and new signatures for target_link_libraries.
# These can't be avoided, because the FindCUDA packed provided by CMake before
# version 3.9 uses the old signature, while other packages use the new signature.
if ("${CMAKE_VERSION}" MATCHES "^3.[0-9].")
    cmake_policy(SET CMP0023 OLD)
endif()

# Set release as the default build type.
# Otherwise, CMake will default to debug.
if (NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE release CACHE STRING "Choose the type of build." FORCE)
  # Set the possible values of build type for cmake-gui
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "debug" "release")
endif()

find_package(HPX REQUIRED)

# compilation flags
set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
include("CompilerOptions")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CXXOPT_DEBUG} ${CXXOPT_CXX11} ${CXXOPT_PTHREAD} ${CXXOPT_WALL}")

# this generates a .json file with full compilation command for each file
set(CMAKE_EXPORT_COMPILE_COMMANDS "YES")

# generated .a and .so go into /lib
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

#----------------------------------------------------------
# Option to enable assertions
#----------------------------------------------------------
option(ARB_WITH_ASSERTIONS "enable EXPECTS() assertions in code" OFF)
if(ARB_WITH_ASSERTIONS)
    add_definitions("-DARB_HAVE_ASSERTIONS")
endif()

#----------------------------------------------------------
# Option to enable traces
#----------------------------------------------------------
option(ARB_WITH_TRACE "enable TRACE() macros in code" OFF)
if(ARB_WITH_TRACE)
    add_definitions("-DARB_HAVE_TRACE")
endif()

#----------------------------------------------------------
# Option to disable auto running of modcc compiler
#----------------------------------------------------------
option(ARB_AUTO_RUN_MODCC_ON_CHANGES
  "Rerun modcc compiler whenever *.mod file or modcc compiler change" ON)

#----------------------------------------------------------
# prepare list of libraries/includes needed by external libs
#----------------------------------------------------------
set(EXTERNAL_LIBRARIES "")
set(EXTERNAL_INCLUDES "")

#----------------------------------------------------------
# list of libraries built inside Arbor
#----------------------------------------------------------
#set(ARB_LIBRARIES "")
set(ARB_LIBRARIES ${HPX_LIBRARIES})
include_directories(${HPX_INCLUDE_DIRS})


#----------------------------------------------------------
# Threading model selection
#----------------------------------------------------------
set(ARB_THREADING_MODEL "cthread" CACHE STRING "set the threading model, one of cthread/tbb/serial")
set_property(CACHE ARB_THREADING_MODEL PROPERTY STRINGS cthread tbb serial )

if(ARB_THREADING_MODEL MATCHES "tbb")
    include(GitSubmodule) # required for check_git_submodule
    check_git_submodule(tbb "${CMAKE_SOURCE_DIR}/tbb")
    if(NOT tbb_avail)
        message(FATAL_ERROR "TBB git submodule required.")
    endif()

    # turn off proxy malloc library and test compilation
    option(TBB_BUILD_TBBMALLOC_PROXY OFF)
    option(TBB_BUILD_TESTS           OFF)

    # Use the CMake configuration in the TBB submodule
    # Reset the CXX flags, to avoid the litany of warnings that -Wall
    # gives when compiling TBB.
    set(CMAKE_CXX_FLAGS_TBB_BACK "${CMAKE_CXX_FLAGS}")
    unset(CMAKE_CXX_FLAGS)
    add_subdirectory(tbb)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS_TBB_BACK}")

    # set flags for TBB
    add_definitions(-DARB_HAVE_TBB)
    set(ARB_WITH_TBB TRUE)

    include_directories(${CMAKE_SOURCE_DIR}/tbb/include)

    list(APPEND EXTERNAL_LIBRARIES tbb_static tbbmalloc_static)
    list(APPEND EXTERNAL_LIBRARIES pthread dl)

    # TODO add support for user-supplied tbb implementation,
    # e.g. using an TBB_ROOT variable.

elseif(ARB_THREADING_MODEL MATCHES "cthread")
    find_package(Threads REQUIRED)
    add_definitions(-DARB_HAVE_CTHREAD)
    set(ARB_WITH_CTHREAD TRUE)
    list(APPEND EXTERNAL_LIBRARIES ${CMAKE_THREAD_LIBS_INIT})

    if(CMAKE_USE_PTHREADS_INIT)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")
    endif()
endif()

#----------------------------------------------------------
# libunwind for pretty printing stack traces
#----------------------------------------------------------
find_package(Unwind)
if(UNWIND_FOUND)
    add_definitions(-DWITH_UNWIND)
    include_directories(${UNWIND_INCLUDE_DIR})
    list(APPEND EXTERNAL_LIBRARIES ${UNWIND_LIBRARIES})
endif()

#----------------------------------------------------------
# CUDA support
#----------------------------------------------------------
set(ARB_GPU_MODEL "none" CACHE STRING "The target GPU architecture: one of {none,K20,K80,P100}")
set_property(CACHE ARB_GPU_MODEL PROPERTY STRINGS none K20 K80 P100 )

set(ARB_WITH_CUDA FALSE)

if(NOT ARB_GPU_MODEL MATCHES "none")
    find_package(CUDA REQUIRED)

    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS}
        -Xcudafe --diag_suppress=integer_sign_change
        -Xcudafe --diag_suppress=unsigned_compare_with_zero)

    set(ARB_WITH_CUDA TRUE)
    add_definitions(-DARB_HAVE_GPU)
    include_directories(SYSTEM ${CUDA_INCLUDE_DIRS})
    list(APPEND EXTERNAL_LIBRARIES ${CUDA_LIBRARIES})
endif()

if(ARB_GPU_MODEL MATCHES "K20")
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-arch=sm_35)
    add_definitions(-DARB_CUDA_ARCH=350)
elseif(ARB_GPU_MODEL MATCHES "K80")
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-arch=sm_37)
    add_definitions(-DARB_CUDA_ARCH=370)
elseif(ARB_GPU_MODEL MATCHES "P100")
    set(CUDA_NVCC_FLAGS ${CUDA_NVCC_FLAGS};-arch=sm_60)
    add_definitions(-DARB_CUDA_ARCH=600)
elseif(NOT ARB_GPU_MODEL MATCHES "none")
    message( FATAL_ERROR "-- GPU architecture '${ARB_GPU_MODEL}' not supported. Use one of {none, K20, K80, P100}")
endif()

#----------------------------------------------------------
# Cray/BGQ/Generic Linux/other flag?
#----------------------------------------------------------
set(ARB_SYSTEM_TYPE "Generic" CACHE STRING
    "Choose a system type to customize flags")
set_property(CACHE ARB_SYSTEM_TYPE PROPERTY STRINGS Generic Cray BGQ )

# Cray specific flags
if(${ARB_SYSTEM_TYPE} MATCHES "Cray")
    # we no longer set the -dynamic flag for the compilere here, instead dynamic
    # linking should be enabled by the user by setting the environment variable:
    #   CRAYPE_LINK_TYPE=dynamic
    #set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -dynamic")
    add_definitions(-DARB_HAVE_CRAY)
endif()

#----------------------------------------------------------
# MPI support
#----------------------------------------------------------
set(ARB_DISTRIBUTED_MODEL "serial" CACHE STRING "set the global communication model, one of serial/mpi/dryrun")
set_property(CACHE ARB_DISTRIBUTED_MODEL PROPERTY STRINGS serial mpi dryrun)

if(ARB_DISTRIBUTED_MODEL MATCHES "mpi")
   # BGQ specific flags
   if(${ARB_SYSTEM_TYPE} MATCHES "BGQ" )
      # On BGQ, set CXX to the mpi wrapper, and pass it a static
      add_definitions(-DMPICH2_CONST=const)
      set(MPI_FOUND TRUE)
    endif()

    if (NOT MPI_FOUND)
      find_package(MPI REQUIRED)
    endif()
    include_directories(SYSTEM ${MPI_C_INCLUDE_PATH})
    add_definitions(-DARB_HAVE_MPI)

    # unfortunate workaround for C++ detection in system mpi.h
    add_definitions(-DMPICH_SKIP_MPICXX=1 -DOMPI_SKIP_MPICXX=1)
    set_property(DIRECTORY APPEND_STRING PROPERTY COMPILE_OPTIONS "${MPI_C_COMPILE_FLAGS}")

    set(ARB_WITH_MPI TRUE)

elseif(ARB_DISTRIBUTED_MODEL MATCHES "dryrun")
    add_definitions(-DARB_HAVE_DRYRUN)
    set(ARB_WITH_DRYRUN TRUE)

elseif(ARB_DISTRIBUTED_MODEL MATCHES "serial")
    # no additional set up needed

else()
    message( FATAL_ERROR "-- Distributed communication model '${ARB_DISTRIBUTED_MODEL}' not supported, use one of serial/mpi/dryrun")
endif()

#----------------------------------------------------------
# Built-in profiler
#----------------------------------------------------------
option(ARB_WITH_PROFILING "use built-in profiling" OFF)
if(ARB_WITH_PROFILING)
    add_definitions(-DARB_HAVE_PROFILING)
endif()

#----------------------------------------------------------
# Modcc vectorization target
#----------------------------------------------------------
option(ARB_VECTORIZE "use explicit SIMD code in generated mechanisms" OFF)

#----------------------------------------------------------
# Target microarchitecture for building arbor libraries
#----------------------------------------------------------
set(ARB_ARCH "" CACHE STRING "Target architecture for arbor libraries")
if(ARB_ARCH)
    # Sets CXXOPT_ARCH variable accordingly:
    set_arch_target("${ARB_ARCH}")
endif()

#----------------------------------------------------------
# Only build modcc if it has not already been installed.
# This is useful if cross compiling for KNL, when it is not desirable to compile
# modcc with the same flags that are used for the KNL target.
#----------------------------------------------------------
set(use_external_modcc OFF)
find_program(MODCC_BIN modcc)
if(MODCC_BIN)
    set(use_external_modcc ON)
    set(modcc "${MODCC_BIN}")
else()
    set(modcc $<TARGET_FILE:modcc>)
endif()

#----------------------------------------------------------
# Validation data generation
#----------------------------------------------------------
# destination directory for generated data
set(ARB_VALIDATION_DATA_DIR "${PROJECT_SOURCE_DIR}/validation/data" CACHE PATH
  "location of generated validation data")

#----------------------------------------------------------
# Whether to build validation data
#----------------------------------------------------------
# turn off by default
option(ARB_BUILD_VALIDATION_DATA "generate validation data" OFF)
if (ARB_BUILD_VALIDATION_DATA)
    # Whether to attempt to use julia to build validation data
    find_program(JULIA_BIN julia)
    if(JULIA_BIN STREQUAL "JULIA_BIN-NOTFOUND")
        message(STATUS "julia not found; will not automatically build validation data sets from julia scripts")
        set(ARB_BUILD_JULIA_VALIDATION_DATA FALSE)
    else()
        set(ARB_BUILD_JULIA_VALIDATION_DATA TRUE)
    endif()

    # Whether to attempt to use nrniv to build validation data
    # (if we find nrniv, do)
    find_program(NRNIV_BIN nrniv)
    if(NRNIV_BIN STREQUAL "NRNIV_BIN-NOTFOUND")
        message(STATUS "nrniv not found; will not automatically build NEURON validation data sets")
        set(ARB_BUILD_NRN_VALIDATION_DATA FALSE)
    else()
        set(ARB_BUILD_NRN_VALIDATION_DATA TRUE)
    endif()
endif()

#----------------------------------------------------------
# Setup include dirs
#----------------------------------------------------------
include_directories(
    "${PROJECT_SOURCE_DIR}/tclap"
    "${PROJECT_SOURCE_DIR}/include"
    "${PROJECT_SOURCE_DIR}/src"
    "${PROJECT_SOURCE_DIR}/modcc"
    "${PROJECT_SOURCE_DIR}")
if(EXTERNAL_INCLUDES)
  include_directories("${EXTERNAL_INCLUDES}")
endif()

#----------------------------------------------------------
# Setup subdirs
#----------------------------------------------------------
# only include validation data if flag is set
if(ARB_BUILD_VALIDATION_DATA)
    add_subdirectory(validation)
endif()

# only compile modcc if it is not provided externally
if(NOT use_external_modcc)
    add_subdirectory(modcc)
endif()

#----------------------------------------------------------
# set up for targets that require git submodules.
#----------------------------------------------------------
include(GitSubmodule) # required for check_git_submodule
include(ErrorTarget)  # reguired for add_error_target
check_git_submodule(rtdtheme "${PROJECT_SOURCE_DIR}/doc/rtd_theme")

add_subdirectory(src)
add_subdirectory(mechanisms) # after src path so that gpu_mechanism library is last on link line
add_subdirectory(tests)
add_subdirectory(example)
add_subdirectory(lmorpho)
if (rtdtheme_avail)
    add_subdirectory(doc)
else()
    add_error_target( docs
        "Generating Sphinx documentation"
        "The git submodule for read the docs is not available")
endif()

